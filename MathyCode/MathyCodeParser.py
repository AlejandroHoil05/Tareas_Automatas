# Generated from MathyCode.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,32,106,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,1,0,1,0,4,0,21,8,0,11,0,12,0,22,1,0,1,0,1,1,1,
        1,1,1,1,1,1,1,1,1,3,1,33,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,
        43,8,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,67,8,3,1,4,1,4,1,4,1,5,1,5,1,5,
        1,5,4,5,76,8,5,11,5,12,5,77,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,
        1,6,1,6,1,6,3,6,92,8,6,1,7,1,7,1,7,4,7,97,8,7,11,7,12,7,98,1,7,1,
        7,1,8,1,8,1,8,1,8,0,0,9,0,2,4,6,8,10,12,14,16,0,3,1,0,6,7,1,0,29,
        30,2,0,29,29,31,31,113,0,18,1,0,0,0,2,32,1,0,0,0,4,42,1,0,0,0,6,
        66,1,0,0,0,8,68,1,0,0,0,10,71,1,0,0,0,12,91,1,0,0,0,14,93,1,0,0,
        0,16,102,1,0,0,0,18,20,5,2,0,0,19,21,3,2,1,0,20,19,1,0,0,0,21,22,
        1,0,0,0,22,20,1,0,0,0,22,23,1,0,0,0,23,24,1,0,0,0,24,25,5,3,0,0,
        25,1,1,0,0,0,26,33,3,4,2,0,27,33,3,6,3,0,28,33,3,10,5,0,29,33,3,
        14,7,0,30,33,3,8,4,0,31,33,3,16,8,0,32,26,1,0,0,0,32,27,1,0,0,0,
        32,28,1,0,0,0,32,29,1,0,0,0,32,30,1,0,0,0,32,31,1,0,0,0,33,3,1,0,
        0,0,34,35,5,4,0,0,35,36,5,29,0,0,36,37,5,1,0,0,37,43,5,30,0,0,38,
        39,5,5,0,0,39,40,5,29,0,0,40,41,5,1,0,0,41,43,7,0,0,0,42,34,1,0,
        0,0,42,38,1,0,0,0,43,5,1,0,0,0,44,45,5,8,0,0,45,46,5,29,0,0,46,47,
        5,19,0,0,47,67,7,1,0,0,48,49,5,9,0,0,49,50,5,29,0,0,50,51,5,20,0,
        0,51,67,7,1,0,0,52,53,5,10,0,0,53,54,5,29,0,0,54,55,5,21,0,0,55,
        67,7,1,0,0,56,57,5,11,0,0,57,58,5,29,0,0,58,59,5,18,0,0,59,67,7,
        1,0,0,60,61,5,12,0,0,61,62,5,14,0,0,62,63,5,20,0,0,63,67,5,29,0,
        0,64,65,5,13,0,0,65,67,5,29,0,0,66,44,1,0,0,0,66,48,1,0,0,0,66,52,
        1,0,0,0,66,56,1,0,0,0,66,60,1,0,0,0,66,64,1,0,0,0,67,7,1,0,0,0,68,
        69,5,15,0,0,69,70,7,2,0,0,70,9,1,0,0,0,71,72,5,22,0,0,72,73,3,12,
        6,0,73,75,5,23,0,0,74,76,3,2,1,0,75,74,1,0,0,0,76,77,1,0,0,0,77,
        75,1,0,0,0,77,78,1,0,0,0,78,79,1,0,0,0,79,80,5,3,0,0,80,11,1,0,0,
        0,81,82,7,1,0,0,82,83,5,26,0,0,83,92,7,1,0,0,84,85,7,1,0,0,85,86,
        5,27,0,0,86,92,7,1,0,0,87,88,7,1,0,0,88,89,5,28,0,0,89,92,7,1,0,
        0,90,92,5,5,0,0,91,81,1,0,0,0,91,84,1,0,0,0,91,87,1,0,0,0,91,90,
        1,0,0,0,92,13,1,0,0,0,93,94,5,24,0,0,94,96,3,12,6,0,95,97,3,2,1,
        0,96,95,1,0,0,0,97,98,1,0,0,0,98,96,1,0,0,0,98,99,1,0,0,0,99,100,
        1,0,0,0,100,101,5,3,0,0,101,15,1,0,0,0,102,103,5,16,0,0,103,104,
        5,31,0,0,104,17,1,0,0,0,7,22,32,42,66,77,91,98
    ]

class MathyCodeParser ( Parser ):

    grammarFileName = "MathyCode.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'='", "'EMPEZAR'", "'FIN'", "'TESORO'", 
                     "'RESPUESTA'", "'VERDADERO'", "'FALSO'", "'COMBINA'", 
                     "'QUITA'", "'MULTIPLICA'", "'DIVIDE'", "'DESCUBRE'", 
                     "'POTENCIA'", "'RAIZ'", "'MUESTRA'", "'NOTA'", "'ELIGE'", 
                     "'ENTRE'", "'CON'", "'DE'", "'POR'", "'SI'", "'ENTONCES'", 
                     "'MIENTRAS'", "'Y'", "'MAYOR'", "'MENOR'", "'IGUAL'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "EMPEZAR", "FIN", "TESORO", 
                      "RESPUESTA", "VERDADERO", "FALSO", "COMBINA", "QUITA", 
                      "MULTIPLICA", "DIVIDE", "DESCUBRE", "POTENCIA", "RAIZ", 
                      "MUESTRA", "NOTA", "ELIGE", "ENTRE", "CON", "DE", 
                      "POR", "SI", "ENTONCES", "MIENTRAS", "Y", "MAYOR", 
                      "MENOR", "IGUAL", "ID", "NUMBER", "STRING", "WS" ]

    RULE_programa = 0
    RULE_instruccion = 1
    RULE_declaracion = 2
    RULE_operacion = 3
    RULE_muestra = 4
    RULE_condicion = 5
    RULE_condicionLogica = 6
    RULE_ciclo = 7
    RULE_comentario = 8

    ruleNames =  [ "programa", "instruccion", "declaracion", "operacion", 
                   "muestra", "condicion", "condicionLogica", "ciclo", "comentario" ]

    EOF = Token.EOF
    T__0=1
    EMPEZAR=2
    FIN=3
    TESORO=4
    RESPUESTA=5
    VERDADERO=6
    FALSO=7
    COMBINA=8
    QUITA=9
    MULTIPLICA=10
    DIVIDE=11
    DESCUBRE=12
    POTENCIA=13
    RAIZ=14
    MUESTRA=15
    NOTA=16
    ELIGE=17
    ENTRE=18
    CON=19
    DE=20
    POR=21
    SI=22
    ENTONCES=23
    MIENTRAS=24
    Y=25
    MAYOR=26
    MENOR=27
    IGUAL=28
    ID=29
    NUMBER=30
    STRING=31
    WS=32

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EMPEZAR(self):
            return self.getToken(MathyCodeParser.EMPEZAR, 0)

        def FIN(self):
            return self.getToken(MathyCodeParser.FIN, 0)

        def instruccion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MathyCodeParser.InstruccionContext)
            else:
                return self.getTypedRuleContext(MathyCodeParser.InstruccionContext,i)


        def getRuleIndex(self):
            return MathyCodeParser.RULE_programa

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrograma" ):
                listener.enterPrograma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrograma" ):
                listener.exitPrograma(self)




    def programa(self):

        localctx = MathyCodeParser.ProgramaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_programa)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 18
            self.match(MathyCodeParser.EMPEZAR)
            self.state = 20 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 19
                self.instruccion()
                self.state = 22 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 21086000) != 0)):
                    break

            self.state = 24
            self.match(MathyCodeParser.FIN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstruccionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaracion(self):
            return self.getTypedRuleContext(MathyCodeParser.DeclaracionContext,0)


        def operacion(self):
            return self.getTypedRuleContext(MathyCodeParser.OperacionContext,0)


        def condicion(self):
            return self.getTypedRuleContext(MathyCodeParser.CondicionContext,0)


        def ciclo(self):
            return self.getTypedRuleContext(MathyCodeParser.CicloContext,0)


        def muestra(self):
            return self.getTypedRuleContext(MathyCodeParser.MuestraContext,0)


        def comentario(self):
            return self.getTypedRuleContext(MathyCodeParser.ComentarioContext,0)


        def getRuleIndex(self):
            return MathyCodeParser.RULE_instruccion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruccion" ):
                listener.enterInstruccion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruccion" ):
                listener.exitInstruccion(self)




    def instruccion(self):

        localctx = MathyCodeParser.InstruccionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_instruccion)
        try:
            self.state = 32
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 26
                self.declaracion()
                pass
            elif token in [8, 9, 10, 11, 12, 13]:
                self.enterOuterAlt(localctx, 2)
                self.state = 27
                self.operacion()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 3)
                self.state = 28
                self.condicion()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 4)
                self.state = 29
                self.ciclo()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 5)
                self.state = 30
                self.muestra()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 6)
                self.state = 31
                self.comentario()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclaracionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TESORO(self):
            return self.getToken(MathyCodeParser.TESORO, 0)

        def ID(self):
            return self.getToken(MathyCodeParser.ID, 0)

        def NUMBER(self):
            return self.getToken(MathyCodeParser.NUMBER, 0)

        def RESPUESTA(self):
            return self.getToken(MathyCodeParser.RESPUESTA, 0)

        def VERDADERO(self):
            return self.getToken(MathyCodeParser.VERDADERO, 0)

        def FALSO(self):
            return self.getToken(MathyCodeParser.FALSO, 0)

        def getRuleIndex(self):
            return MathyCodeParser.RULE_declaracion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaracion" ):
                listener.enterDeclaracion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaracion" ):
                listener.exitDeclaracion(self)




    def declaracion(self):

        localctx = MathyCodeParser.DeclaracionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_declaracion)
        self._la = 0 # Token type
        try:
            self.state = 42
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 34
                self.match(MathyCodeParser.TESORO)
                self.state = 35
                self.match(MathyCodeParser.ID)
                self.state = 36
                self.match(MathyCodeParser.T__0)
                self.state = 37
                self.match(MathyCodeParser.NUMBER)
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 38
                self.match(MathyCodeParser.RESPUESTA)
                self.state = 39
                self.match(MathyCodeParser.ID)
                self.state = 40
                self.match(MathyCodeParser.T__0)
                self.state = 41
                _la = self._input.LA(1)
                if not(_la==6 or _la==7):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperacionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMBINA(self):
            return self.getToken(MathyCodeParser.COMBINA, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(MathyCodeParser.ID)
            else:
                return self.getToken(MathyCodeParser.ID, i)

        def CON(self):
            return self.getToken(MathyCodeParser.CON, 0)

        def NUMBER(self):
            return self.getToken(MathyCodeParser.NUMBER, 0)

        def QUITA(self):
            return self.getToken(MathyCodeParser.QUITA, 0)

        def DE(self):
            return self.getToken(MathyCodeParser.DE, 0)

        def MULTIPLICA(self):
            return self.getToken(MathyCodeParser.MULTIPLICA, 0)

        def POR(self):
            return self.getToken(MathyCodeParser.POR, 0)

        def DIVIDE(self):
            return self.getToken(MathyCodeParser.DIVIDE, 0)

        def ENTRE(self):
            return self.getToken(MathyCodeParser.ENTRE, 0)

        def DESCUBRE(self):
            return self.getToken(MathyCodeParser.DESCUBRE, 0)

        def RAIZ(self):
            return self.getToken(MathyCodeParser.RAIZ, 0)

        def POTENCIA(self):
            return self.getToken(MathyCodeParser.POTENCIA, 0)

        def getRuleIndex(self):
            return MathyCodeParser.RULE_operacion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperacion" ):
                listener.enterOperacion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperacion" ):
                listener.exitOperacion(self)




    def operacion(self):

        localctx = MathyCodeParser.OperacionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_operacion)
        self._la = 0 # Token type
        try:
            self.state = 66
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.match(MathyCodeParser.COMBINA)
                self.state = 45
                self.match(MathyCodeParser.ID)
                self.state = 46
                self.match(MathyCodeParser.CON)
                self.state = 47
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 48
                self.match(MathyCodeParser.QUITA)
                self.state = 49
                self.match(MathyCodeParser.ID)
                self.state = 50
                self.match(MathyCodeParser.DE)
                self.state = 51
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 3)
                self.state = 52
                self.match(MathyCodeParser.MULTIPLICA)
                self.state = 53
                self.match(MathyCodeParser.ID)
                self.state = 54
                self.match(MathyCodeParser.POR)
                self.state = 55
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 4)
                self.state = 56
                self.match(MathyCodeParser.DIVIDE)
                self.state = 57
                self.match(MathyCodeParser.ID)
                self.state = 58
                self.match(MathyCodeParser.ENTRE)
                self.state = 59
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 60
                self.match(MathyCodeParser.DESCUBRE)
                self.state = 61
                self.match(MathyCodeParser.RAIZ)
                self.state = 62
                self.match(MathyCodeParser.DE)
                self.state = 63
                self.match(MathyCodeParser.ID)
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 6)
                self.state = 64
                self.match(MathyCodeParser.POTENCIA)
                self.state = 65
                self.match(MathyCodeParser.ID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MuestraContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUESTRA(self):
            return self.getToken(MathyCodeParser.MUESTRA, 0)

        def ID(self):
            return self.getToken(MathyCodeParser.ID, 0)

        def STRING(self):
            return self.getToken(MathyCodeParser.STRING, 0)

        def getRuleIndex(self):
            return MathyCodeParser.RULE_muestra

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMuestra" ):
                listener.enterMuestra(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMuestra" ):
                listener.exitMuestra(self)




    def muestra(self):

        localctx = MathyCodeParser.MuestraContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_muestra)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(MathyCodeParser.MUESTRA)
            self.state = 69
            _la = self._input.LA(1)
            if not(_la==29 or _la==31):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondicionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI(self):
            return self.getToken(MathyCodeParser.SI, 0)

        def condicionLogica(self):
            return self.getTypedRuleContext(MathyCodeParser.CondicionLogicaContext,0)


        def ENTONCES(self):
            return self.getToken(MathyCodeParser.ENTONCES, 0)

        def FIN(self):
            return self.getToken(MathyCodeParser.FIN, 0)

        def instruccion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MathyCodeParser.InstruccionContext)
            else:
                return self.getTypedRuleContext(MathyCodeParser.InstruccionContext,i)


        def getRuleIndex(self):
            return MathyCodeParser.RULE_condicion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondicion" ):
                listener.enterCondicion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondicion" ):
                listener.exitCondicion(self)




    def condicion(self):

        localctx = MathyCodeParser.CondicionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_condicion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 71
            self.match(MathyCodeParser.SI)
            self.state = 72
            self.condicionLogica()
            self.state = 73
            self.match(MathyCodeParser.ENTONCES)
            self.state = 75 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 74
                self.instruccion()
                self.state = 77 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 21086000) != 0)):
                    break

            self.state = 79
            self.match(MathyCodeParser.FIN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondicionLogicaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAYOR(self):
            return self.getToken(MathyCodeParser.MAYOR, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(MathyCodeParser.ID)
            else:
                return self.getToken(MathyCodeParser.ID, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MathyCodeParser.NUMBER)
            else:
                return self.getToken(MathyCodeParser.NUMBER, i)

        def MENOR(self):
            return self.getToken(MathyCodeParser.MENOR, 0)

        def IGUAL(self):
            return self.getToken(MathyCodeParser.IGUAL, 0)

        def RESPUESTA(self):
            return self.getToken(MathyCodeParser.RESPUESTA, 0)

        def getRuleIndex(self):
            return MathyCodeParser.RULE_condicionLogica

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondicionLogica" ):
                listener.enterCondicionLogica(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondicionLogica" ):
                listener.exitCondicionLogica(self)




    def condicionLogica(self):

        localctx = MathyCodeParser.CondicionLogicaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_condicionLogica)
        self._la = 0 # Token type
        try:
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 81
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 82
                self.match(MathyCodeParser.MAYOR)
                self.state = 83
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 85
                self.match(MathyCodeParser.MENOR)
                self.state = 86
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 87
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 88
                self.match(MathyCodeParser.IGUAL)
                self.state = 89
                _la = self._input.LA(1)
                if not(_la==29 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 90
                self.match(MathyCodeParser.RESPUESTA)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CicloContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MIENTRAS(self):
            return self.getToken(MathyCodeParser.MIENTRAS, 0)

        def condicionLogica(self):
            return self.getTypedRuleContext(MathyCodeParser.CondicionLogicaContext,0)


        def FIN(self):
            return self.getToken(MathyCodeParser.FIN, 0)

        def instruccion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MathyCodeParser.InstruccionContext)
            else:
                return self.getTypedRuleContext(MathyCodeParser.InstruccionContext,i)


        def getRuleIndex(self):
            return MathyCodeParser.RULE_ciclo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCiclo" ):
                listener.enterCiclo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCiclo" ):
                listener.exitCiclo(self)




    def ciclo(self):

        localctx = MathyCodeParser.CicloContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ciclo)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(MathyCodeParser.MIENTRAS)
            self.state = 94
            self.condicionLogica()
            self.state = 96 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 95
                self.instruccion()
                self.state = 98 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 21086000) != 0)):
                    break

            self.state = 100
            self.match(MathyCodeParser.FIN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComentarioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOTA(self):
            return self.getToken(MathyCodeParser.NOTA, 0)

        def STRING(self):
            return self.getToken(MathyCodeParser.STRING, 0)

        def getRuleIndex(self):
            return MathyCodeParser.RULE_comentario

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComentario" ):
                listener.enterComentario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComentario" ):
                listener.exitComentario(self)




    def comentario(self):

        localctx = MathyCodeParser.ComentarioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_comentario)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(MathyCodeParser.NOTA)
            self.state = 103
            self.match(MathyCodeParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





